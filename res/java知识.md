# 一、java 基础

## 集合类知识

* stringbuffer与Stringbuilder的区别

  > 1、执行速度stringbuilder大于stringbuffer ，因为stringbuilder时线程非安全的。
  >
  > 2、stringbuffer与stringbuilder 都是在一个对象上操作，string是创建对象操作。
  >
  > 3、操作少量数据 =string       单线程操作大量数据stringBuidler  多线程操作大量数据 stringbuffer.

* set与list的区别

  > set 是无序的，无法添加重复元素
  >
  > list 是有序的，可以添加重复元素

* arraylist

  > 1、底层数据结构是数据，查询快，添加，删除与插入 比链表结构的数组要慢，但是内存比链表结构的list 要小
  >
  > 2、put 时，会判断数组大小是否够用，如何不够用，则会创建一个时原来数组1.5倍的数组，然后将数据复制到这个新数组中。

* linklist

  > 1、基于双向链表结构，增删改 快，查询慢，内存占用稍大。

* hashmap

  > 1、数据结构时hash数组+链表的结构
  >
  > 2、put的时候对key的hashCode做hash，从而得到bucket位置，进行存储，hashmap会根据当前bucket的占用情况自动调整容量(吵load facotr(0.75) 则resize为原来的2倍)。如果发生碰撞，hashmap通过链表将产生碰撞冲突的元素组织起来。get的时候，通过hascode 计算hash的值 从而得到bucket的位置，然后调用equals()确定键值对。

* treemap

  > 1、底层数据结构是红黑树，按照key大小排列。
  >
  > 2、添加，如果存在 就会被替换掉，如果不存在，添加一个节点，然后对坐红黑树的平衡操作。
  >
  > 3、获取，按照二叉树搜索的方式进行搜索，搜到返回。

* linkedHashMap

  > 1、linkedHashMap数据结构是数组和链表，并且依靠双向链表保证迭代顺序是插入的顺序。

## 集合类面试题

* ArrayList 跟linkList的区别

  * 1、底层数据结构不同，ArrayList 数据结构是数组，通过索引可以查询到对应的数据。LinkedList 数据结构是双向链表结构，每个元素都有上一个和下一个元素的引用。
  * 2、 相对于ArrayList ,LinkedList 的插入、添加、删除速度更快，因为元素添加到集合种任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。但是，查询速度更慢，数组通过索引就可以查到数据，链表只能挨个查询。
  * 3、LinkedList比ArrayList 更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向上一个元素，一个指向下一个元素。
* ArrayList的数组大小是如何保证可以添加大量数据的
  * arraylist 有一个自动扩容的机制，如果arraylist的大小已经不满足需求时，那么将数组变原长度的1.5倍，之后操作就是把老的数组拷贝到新的数组里面。
* hashMap的实现原理

  * HashMap 结构
* 数据+链表。每个entry元素就是一个数组的元素，它将key-value 的数值以键值队的形式进行存储，并且entry 是一个链表结构，next 指向另外一个entry 元素
  * HashMap 工作原理
    * HashMap 基于 hashing 原理，我们通过 put() 和 get() 方法储存和获取对象。当我们将键值对传递给 put() 方法时，它调用键对象的 hashCode() 方法来计算 hashcode，让后找到 bucket 位置来储存 Entry 对象。当两个对象的 hashcode 相同时，它们的 bucket 位置相同，‘碰撞’会发生。因为 HashMap 使用链表存储对象，这个 Entry 会存储在链表中，当获取对象时，通过键对象的 equals() 方法找到正确的键值对，然后返回值对象。



## 多线程知识

对java多线程编程的理解

* 线程与进程

  * 线程是程序中单独的控制流，依靠程序进行运行，只能使用分配给程序的资源和环境
  * 进程是执行中的程序，一个进程可以包含一个或者多个线程，进程至少要包含一个线程。
  * 程序中只存在一个线程，实际上主方法就是一个 主线程
  * 多线是在一个程序中运行多个任务，目的是更好的使用cpu资源
  * 一个线程执行到底，相当于单线程，叫串行；多个线程交替执行，抢占cpu时间片，速度很快，称为 线程并发；多个线程在不同的cpu中同时执行 称为线程并行。

* 线程的现实

  * 线程有两种实现方式：1、继承Thread 类，在Run 方法里面实现功能，创建该类的实例对象，调用start()方法。2、实现Runnable 接口，创建该类实例对象，new 出Thread 对象 并将该类对象传递给Thread 构造方法， 然后执行Thread 实例对象的start() 。

    

* 线程的状态

  * 创建状态：准备好了一个多线程的对象。
  * 就绪状态：调用了start()方法，等待cpu进行调度
  * 运行状态：执行run()方法。
  * 阻塞状态：暂停执行执行，可能将资源交给其他线程使用(wait() sleep() )
  * 终止状态(死亡状态):线程销毁了 ；当线程程序执行完，或线程调用stop的时候  initerrupt() 中断线程。

* 线程常用的方法

  * getName ：获取线程名。
  * currentThread();获取当前线程对象。
  * isAlive() 判断线程是否启动
  * join() 线程的强行执行，当调用这个方法的时候，就会优先执行线程，然后继续执行当前程序。
  * sleep() 当前线程进行休眠。
  * yield() 礼让，优先让其他线程执行

* 线程的优先级

  * shePriority() 设置线程的优先级，有一定的影响。不是绝对。

* 线程同步 

  * 多个线程方问 成员变量的时候，由于内存共享的愿意会导致变量的属性值 出问题，所有需要同步代码块，同时只能有一个线程访问该段代码。

* 线程生命周期

  * new Thread() 新建线程 
  * start（） 运行 
  * yield() 其他线程优先执行，然后再执行
  * sleep() wait() 睡眠状态
  * notify()  notifyAll()    恢复运行
  * stop()   销毁

* 锁的类型

  * 悲观锁：使用数据时，一定会有其他线程来修改数据，因此再获取数据的时候会先加锁，确保数据不会被别的线程修改。
  * 乐观锁：使用数据时，不会有其他线程修改数据，所以不添加锁，只是再更新数据的时候去判断之前有没有别的线程更新了这个数据。如果没更新，成功写入。如果更新了，根据不同的实现方式执行不同的操作。
  * 自旋锁:锁住同步资源失败，不阻塞线程。
  * 死锁：当前线程拥有其他线程需要的资源，当前线程等待其他线程已拥有的资源，都不放弃自己拥有的资源.

* #### synchronized关键字

  > 1、当线程视图访问同步代码时，必须得到对象锁，退出或抛出异常时必须释放锁。
  >
  > 2、代码块同步，方法同步。
  >
  > 3、使用场景 
  >
  > ​	1、方法同步 `public synchronized void method1`  锁住对象，不同线程，执行同一对象，线程互斥，达到同步效果；如果是不同对象 则不会。
  >
  > ​	2、代码块同步  `synchronized(this){ //TODO }` 同一，锁住对象
  >
  > ​	3、静态方法同步  `public synchronized static void method3`   锁住得是该类，多个对象，在不同线程中调用这个static 同步方法时，线程互斥，达到同步效果。
  >
  > ​	4、代码块同步 `synchronized(Test.class){ //TODO}` 同三
  >
  > ​	5、代码块同步 `synchronized(o) {}` 这里的 o 可以时任何object对象或数组，谁拥有o这个锁，谁就就够操作该块程序代码。
  
* 线程可见





## 虚拟机

java 虚拟机的回收算法

> 先回收之前 我们需要做对象存活判断，一个是引用计数，一个是可达性分析。
>
> 然后就是 收集的算法有4中，
>
> * 标记-清除 算法，首先 标记出所有需要回收的对象，完成后统一回收。有两缺点，效率不高，清除会内存碎片产生。
> * 复制算法  将内存分为两块，当一块用完了，将还活着的对象复制到另一块，然后将用完了的这块内存清理掉。优点是云行高效，缺点是只有一半的内存，复制长生存期对象也会导致效率降低
> * 标记-整理算法  与标记-清除一样，不同的是 不直接清除内存，而是让存活对象向一端移动，然后清理端边界以外的内存。、
> * 分代收集算法 把java 堆分为 新生代 和老年代 ，新生代 就是每次收集时会有大批对象死去，就用复制算法。老年代相反，每次收集时 对象存活率高，就使用 标记-清理 或者 标记-整理。













