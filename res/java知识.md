# 一、java 基础

## 集合类知识

* stringbuffer与Stringbuilder的区别

  > 1、执行速度stringbuilder大于stringbuffer ，因为stringbuilder时线程非安全的。
  >
  > 2、stringbuffer与stringbuilder 都是在一个对象上操作，string是创建对象操作。
  >
  > 3、操作少量数据 =string       单线程操作大量数据stringBuidler  多线程操作大量数据 stringbuffer.
  >
  > 4.使用StringBuffer类的场景：在频繁进行字符串运算（如拼接、替换、删除等），并且运行在多线程环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装。
  >
  > 5.使用StringBuilder类的场景：在频繁进行字符串运算（如拼接、替换、和删除等），并且运行在单线程的环境中，则可以考虑使用StringBuilder，如SQL语句的拼装、JSON封装等。

* set与list的区别

  > set 是无序的，无法添加重复元素
  >
  > list 是有序的，可以添加重复元素

* arraylist

  > 1、底层数据结构是数据，查询快，添加，删除与插入 比链表结构的数组要慢，但是内存比链表结构的list 要小
  >
  > 2、put 时，会判断数组大小是否够用，如何不够用，则会创建一个时原来数组1.5倍的数组，然后将数据复制到这个新数组中。

* linklist

  > 1、基于双向链表结构，增删改 快，查询慢，内存占用稍大。

* hashmap

  > 1、数据结构时hash数组+链表的结构
  >
  > 2、put的时候对key的hashCode做hash，从而得到bucket位置，进行存储，hashmap会根据当前bucket的占用情况自动调整容量(吵load facotr(0.75) 则resize为原来的2倍)。如果发生碰撞，hashmap通过链表将产生碰撞冲突的元素组织起来。get的时候，通过hascode 计算hash的值 从而得到bucket的位置，然后调用equals()确定键值对。

* treemap

  > 1、底层数据结构是红黑树，按照key大小排列。
  >
  > 2、添加，如果存在 就会被替换掉，如果不存在，添加一个节点，然后对坐红黑树的平衡操作。
  >
  > 3、获取，按照二叉树搜索的方式进行搜索，搜到返回。

* linkedHashMap

  > 1、linkedHashMap数据结构是数组和链表，并且依靠双向链表保证迭代顺序是插入的顺序。

## 集合类面试题

* ArrayList 跟linkList的区别

  * 1、底层数据结构不同，ArrayList 数据结构是数组，通过索引可以查询到对应的数据。LinkedList 数据结构是双向链表结构，每个元素都有上一个和下一个元素的引用。
  * 2、 相对于ArrayList ,LinkedList 的插入、添加、删除速度更快，因为元素添加到集合种任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。但是，查询速度更慢，数组通过索引就可以查到数据，链表只能挨个查询。
  * 3、LinkedList比ArrayList 更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向上一个元素，一个指向下一个元素。
* ArrayList的数组大小是如何保证可以添加大量数据的
  * arraylist 有一个自动扩容的机制，如果arraylist的大小已经不满足需求时，那么将数组变原长度的1.5倍，之后操作就是把老的数组拷贝到新的数组里面。
* hashMap的实现原理

  * HashMap 结构
* 数据+链表。每个entry元素就是一个数组的元素，它将key-value 的数值以键值队的形式进行存储，并且entry 是一个链表结构，next 指向另外一个entry 元素
  * HashMap 工作原理
    * HashMap 基于 hashing 原理，我们通过 put() 和 get() 方法储存和获取对象。当我们将键值对传递给 put() 方法时，它调用键对象的 hashCode() 方法来计算 hashcode，让后找到 bucket 位置来储存 Entry 对象。当两个对象的 hashcode 相同时，它们的 bucket 位置相同，‘碰撞’会发生。因为 HashMap 使用链表存储对象，这个 Entry 会存储在链表中，当获取对象时，通过键对象的 equals() 方法找到正确的键值对，然后返回值对象。



## 多线程知识

对java多线程编程的理解

* 线程与进程

  * 线程是程序中单独的控制流，依靠程序进行运行，只能使用分配给程序的资源和环境
  * 进程是执行中的程序，一个进程可以包含一个或者多个线程，进程至少要包含一个线程。
  * 程序中只存在一个线程，实际上主方法就是一个 主线程
  * 多线是在一个程序中运行多个任务，目的是更好的使用cpu资源
  * 一个线程执行到底，相当于单线程，叫串行；多个线程交替执行，抢占cpu时间片，速度很快，称为 线程并发；多个线程在不同的cpu中同时执行 称为线程并行。

* 线程的现实

  * 线程有两种实现方式：1、继承Thread 类，在Run 方法里面实现功能，创建该类的实例对象，调用start()方法。2、实现Runnable 接口，创建该类实例对象，new 出Thread 对象 并将该类对象传递给Thread 构造方法， 然后执行Thread 实例对象的start() 。

    

* 线程的状态

  * 创建状态：准备好了一个多线程的对象。
  * 就绪状态：调用了start()方法，等待cpu进行调度
  * 运行状态：执行run()方法。
  * 阻塞状态：暂停执行执行，可能将资源交给其他线程使用(wait() sleep() )
  * 终止状态(死亡状态):线程销毁了 ；当线程程序执行完，或线程调用stop的时候  initerrupt() 中断线程。

* 线程常用的方法

  * getName ：获取线程名。
  * currentThread();获取当前线程对象。
  * isAlive() 判断线程是否启动
  * join() 线程的强行执行，当调用这个方法的时候，就会优先执行线程，然后继续执行当前程序。
  * sleep() 当前线程进行休眠。
  * yield() 礼让，优先让其他线程执行

* 线程的优先级

  * shePriority() 设置线程的优先级，有一定的影响。不是绝对。

* 线程同步 

  * 多个线程方问 成员变量的时候，由于内存共享的愿意会导致变量的属性值 出问题，所有需要同步代码块，同时只能有一个线程访问该段代码。

* 线程生命周期

  * new Thread() 新建线程 
  * start（） 运行 
  * yield() 其他线程优先执行，然后再执行
  * sleep() wait() 睡眠状态
  * notify()  notifyAll()    恢复运行
  * stop()   销毁

* 锁的类型

  * 悲观锁：使用数据时，一定会有其他线程来修改数据，因此再获取数据的时候会先加锁，确保数据不会被别的线程修改。
  * 乐观锁：使用数据时，不会有其他线程修改数据，所以不添加锁，只是再更新数据的时候去判断之前有没有别的线程更新了这个数据。如果没更新，成功写入。如果更新了，根据不同的实现方式执行不同的操作。
  * 自旋锁:锁住同步资源失败，不阻塞线程。
  * 死锁：当前线程拥有其他线程需要的资源，当前线程等待其他线程已拥有的资源，都不放弃自己拥有的资源.

* #### synchronized关键字

  > 1、当线程视图访问同步代码时，必须得到对象锁，退出或抛出异常时必须释放锁。
  >
  > 2、代码块同步，方法同步。
  >
  > 3、使用场景 
  >
  > ​	1、方法同步 `public synchronized void method1`  锁住对象，不同线程，执行同一对象，线程互斥，达到同步效果；如果是不同对象 则不会。
  >
  > ​	2、代码块同步  `synchronized(this){ //TODO }` 同一，锁住对象
  >
  > ​	3、静态方法同步  `public synchronized static void method3`   锁住得是该类，多个对象，在不同线程中调用这个static 同步方法时，线程互斥，达到同步效果。
  >
  > ​	4、代码块同步 `synchronized(Test.class){ //TODO}` 同三
  >
  > ​	5、代码块同步 `synchronized(o) {}` 这里的 o 可以时任何object对象或数组，谁拥有o这个锁，谁就就够操作该块程序代码。
  
* 线程可见

  * 1、jvm主内存与工作内存

    * 主内存:本地方法区和堆
    * 工作内存:该线程的私有栈，对主内存变量拷贝的寄存器(包括 程序计数器PC和CUP的高速缓冲区)

  * 2、线程对内存间的交互操作:

    > Lock(锁定)：作用于主内存中的变量，把一个变量标识为一条线程独占的状态。
    > Read(读取)：作用于主内存中的变量，把一个变量的值从主内存传输到线程的工作内存中。
    > Load(加载)：作用于工作内存中的变量，把read操作从主内存中得到的变量的值放入工作内存的变量副本中。
    > Use(使用)：作用于工作内存中的变量，把工作内存中一个变量的值传递给执行引擎。
    > Assign(赋值)：作用于工作内存中的变量，把一个从执行引擎接收到的值赋值给工作内存中的变量。
    > Store(存储)：作用于工作内存中的变量，把工作内存中的一个变量的值传送到主内存中。
    > Write(写入)：作用于主内存中的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。
    > Unlock(解锁)：作用于主内存中的变量，把一个处于锁定状态的变量释放出来，之后可被其它线程锁定。
    > 1、在将变量从主内存读取到工作内存中，必须顺序执行read、load；要将变量从工作内存同步回主内存中，必须顺序执行store、write。并且这8种操作必须遵循以下规则：
    > 2、不允许read和load、store和write操作之一单独出现。即不允许一个变量从主内存被读取了，但是工作内存不接受，或者从工作内存回写了但是主内存不接受。
    > 3、不允许一个线程丢弃它最近的一个assign操作，即变量在工作内存被更改后必须同步改更改回主内存。
    > 4、工作内存中的变量在没有执行过assign操作时，不允许无意义的同步回主内存。
    > 5、在执行use前必须已执行load，在执行store前必须已执行assign。
    > 6、一个变量在同一时刻只允许一个线程对其执行lock操作，一个线程可以对同一个变量执行多次lock，但必须执行相同次数的unlock操作才可解锁。
    > 7、 一个线程在lock一个变量的时候，将会清空工作内存中的此变量的值，执行引擎在use前必须重新read和load。
    > 8、线程不允许unlock其他线程的lock操作。并且unlock操作必须是在本线程的lock操作之后。 - 8，在执行unlock之前，必须首先执行了store和write操作。

  * 内存模型与java多线程之间的问题

    > java的多线程并发问题最终都会反映在java的内存模型上，所谓线程安全无非是要控制多个线程对某个资源的有序访问或修改。总结java的内存模型，要解决两个主要的问题：***可见性和有序性\***。
    > 那么，何谓可见性？ 多个线程之间是不能互相传递数据通信的，它们之间的沟通只能通过共享变量来进行。Java内存模型（JMM）规定了jvm有主内存，主内存是多个线程共享的。当new一个对象的时候，也是被分配在主内存中，每个线程都有自己的工作内存，工作内存存储了主存的某些对象的副本，当然线程的工作内存大小是有限制的。当线程操作某个对象时，执行顺序如下：
    > (1) 从主存复制变量到当前工作内存 (read and load)
    > (2) 执行代码，改变共享变量值 (use and assign)
    > (3) 用工作内存数据刷新主存相关内容 (store and write)
    > 当一个共享变量在多个线程的工作内存中都有副本时，如果一个线程修改了这个共享变量，那么其他线程应该能够看到这个被修改后的值，这就是多线程的可见性问题

  * volatile关键字

    > volatile是java提供的一种同步手段，只不过它是轻量级的同步，为什么这么说，因为volatile只能保证多线程的内存可见性，不能保证多线程的执行有序性。而最彻底的同步要保证有序性和可见性，例如synchronized。任何被volatile修饰的变量，都不拷贝副本到工作内存，任何修改都及时写在主存。因此对于Valatile修饰的变量的修改，所有线程马上就能看到，但是volatile不能保证对变量的修改是有序的。

  * 序性

    > 那么继续说什么是序性呢？多个线程执行时，CPU对线程的调度是随机的，我们不知道当前程序被执行到哪步就切换到了下一个线程，线程在引用变量时不能直接从主内存中引用,如果线程工作内存中没有该变量,则会从主内存中拷贝一个副本到工作内存中,这个过程为read-load,完成后线程会引用该副本，线程不能直接为主存中中字段赋值，它会将值指定给工作内存中的变量副本(assign),完成后这个变量副本会同步到主存储区(store-write)，至于何时同步过去，根据JVM实现系统决定。
    > 这里看一个最经典的例子就是银行汇款问题，一个银行账户存款100，这时一个人从该账户取10元，同时另一个人向该账户汇10元，那么余额应该还是100。那么此时可能发生这种情况，A线程负责取款，B线程负责汇款，A从主内存读到100，B从主内存读到100，A执行减10操作，并将数据刷新到主内存，这时主内存数据100-10=90，而B内存执行加10操作，并将数据刷新到主内存，最后主内存数据100+10=110，显然这是一个严重的问题，我们要保证A线程和B线程有序执行，先取款后汇款或者先汇款后取款。
    >
    > 这里将一个非原子操作进行分解分步说明，假设有一个共享变量x，线程Thread1执行x=x+1。从上面的描述中可以知道x=x+1并不是一个原子操作，它的执行过程如下：
    > 1 从主存中读取变量x副本到工作内存
    > 2 给x加1
    > 3 将x加1后的值写回主存
    > 如果另外一个线程b执行x=x-1，执行过程如下：
    > 1 从主存中读取变量x副本到工作内存
    > 2 给x减1
    > 3 将x减1后的值写回主存
    > 那么显然，最终的x的值是不可靠的。假设x现在为10，线程a加1，线程b减1，从表面上看，似乎最终x还是为10，但是多线
    > 程情况下会有这种情况发生：
    > 1：线程a从主存读取x副本到工作内存，工作内存中x值为10
    > 2：线程b从主存读取x副本到工作内存，工作内存中x值为10
    > 3：线程a将工作内存中x加1，工作内存中x值为11
    > 4：线程a将x提交主存中，主存中x为11
    > 5：线程b将工作内存中x值减1，工作内存中x值为9
    > 6：线程b将x提交到中主存中，主存中x为9
    > 同样，x有可能为11，每次执行的结果都是不确定的，因为线程的执行顺序是不可预见的。这是java同步产生的根源，synchronized关键字保证了多个线程对于同步块是互斥的，synchronized作为一种同步手段，解决java多线程的执行有序性和内存可见性，而volatile关键字之解决多线程的内存可见性问题。

  * **synchronized关键字**

    > 每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程，当一个被线程被唤醒(notify)后，才会进入到就绪队列，等待cpu的调度。当一开始线程a第一次执行account.add方法时，jvm会检查锁对象account的就绪队列是否已经有线程在等待，如果有则表明account的锁已经被占用了，由于是第一次运行，account的就绪队列为空，所以线程a获得了锁，执行account.add方法。如果恰好在这个时候，线程b要执行account.minus方法，因为线程a已经获得了锁还没有释放，所以线程b要进入account的就绪队列，等到得到锁后才可以执行。
    > **一个线程执行临界区代码过程如下：**
    > 1 获得同步锁
    > 2 清空工作内存
    > 3 从主存拷贝变量副本到工作内存
    > 4 对这些变量计算
    > 5 将变量从工作内存写回到主存
    > 6 释放锁
    > ***可见，synchronized既保证了多线程的并发有序性，又保证了多线程的内存可见性。\*** notify 不会释放锁，而是通知锁对象的阻塞队列里的某一线程（被阻塞，即主动调用wait方法），进入就绪队列。线程释放锁的方式，通常是 主动调用wait方法、同步代码块结束释放锁资源。notifyall 是 唤醒阻塞队列里的所有阻塞线程，他们都将进入就绪队列，而notify的数量是一个。同步代码块结束释放锁资源，对象就绪队列中的某一线程获得锁资源而开始线程；如果不使用notify 那么阻塞队列 里 线程将一直处于阻塞状态，即使就绪队列里 线程都执行完了，阻塞队列 里 线程也将一直处于阻塞状态.某一线程释放锁之后，将会从就绪队列中 随机找出？（有疑问） 一线程，使之获得锁资源。

  * 

* 





## 虚拟机

java 虚拟机的回收算法

> 先回收之前 我们需要做对象存活判断，一个是引用计数，一个是可达性分析。
>
> 然后就是 收集的算法有4中，
>
> * 标记-清除 算法，首先 标记出所有需要回收的对象，完成后统一回收。有两缺点，效率不高，清除会内存碎片产生。
> * 复制算法  将内存分为两块，当一块用完了，将还活着的对象复制到另一块，然后将用完了的这块内存清理掉。优点是云行高效，缺点是只有一半的内存，复制长生存期对象也会导致效率降低
> * 标记-整理算法  与标记-清除一样，不同的是 不直接清除内存，而是让存活对象向一端移动，然后清理端边界以外的内存。、
> * 分代收集算法 把java 堆分为 新生代 和老年代 ，新生代 就是每次收集时会有大批对象死去，就用复制算法。老年代相反，每次收集时 对象存活率高，就使用 标记-清理 或者 标记-整理。













