# binder原理

# 一、概述

* 1.1binder时一种进程间通信机制，基于开源的OpenBinder实现。
* 1.2android的4大组件之间的通信依赖Binder IPC机制.系统对应用层的服务：AMS、PMS都是基于Binder IPC机制来实现。
* 1.3linux 已有的ipc ：管道、消息队列、共享内存、socket。binder只需要一次数拷贝，而ssocket/管道/消息队列需要两次。binder 基于c/s架构，稳定性好。binder为每个app分配uid，进程的uid是鉴别进程身份的重要标志。（性能、稳定、安全)

## 二、linux下传统的进程通信原理

* 1.1基本概念

  * 进程隔离

    > 1、操作系统中，进程与进程内存是不共享的
    >
    > 2、不同进程数据交互需要采用IPC机制。

  * 进程空间划分:用户空间(User Space)/内核空间(Kernel Space)

    > 1、内核空间是系统内核运行的空间，用户空间是用户程序运行的空间（1G内核/3G用户）
    >
    > 2.它们之间是隔离的。

  * 系统调用:用户态/内核态

    > 1.用户空间对内核空间进行访问，借助系统调用来实现。
    >
    > 2.linux 两级保护机制:0级供系统内核使用  ，3级供用户程序使用。
    >
    > 3.当一个任务(进程)执行系统调用而陷入内核代码中执行时，称进程处于内核运行态(内核态)。此时处理器处于特权级最高的(0级)内核代码中执行。执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。
    >
    > 4.当进程执行用户自己的代码的时候，我们称其处于用户运行态(用户态)。此时处理器在特权级最低的(3级)用户代码中运行。
    >
    > 5.系统调用主要通过如下两个函数来实现
    >
    > copy_from_user()//将数据从用户空间拷贝到内核空间。
    >
    > copy_to_user() //将数据从内核空间拷贝到用户空间。

* 1.2 linux下的传统ipc通信原理

  > 1.消息发送方：数据 ---放入--->内存缓存区中 ----系统调用----> 内核态 ---分配空间--->内核缓存区 -------copy_from_user-------->用户空间的内存缓存区拷贝到内核空间缓冲区中。
  >
  > 2.消息接受方: 用户空间开辟一块内存缓冲区-----copy_to_user----->将数据从内核缓冲区拷贝到接受进程的内存缓冲区。
  >
  > 缺点：
  >
  > 1.性能低下，一次数据传递需要经历：内存缓冲区--->内核缓冲区----->内存缓冲区，需要2次数据拷贝。
  >
  > 2.接受数据的缓冲区由数据接受进程提供，但是接受进程并不知道需要多大的空间来存放将来传递过来的数据，因此只能开辟尽可能达的内存空间或者先调用API接受消息头获取消息体的大小，这种做法不是浪费空间就是浪费时间。
  >
  > 
  >
  > 通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。

  
  
  ![1](/pic_res/binder的由来.jpg)
  
  ![](/pic_res/binder优点.png)

## 三、binder 跨进程通信原理

* 3.1  动态内核可加载模块 && 内存映射

  * 动态内核可加载模块

    > 1.传统ipc机制 (管道，socket) 都是内核的一部分,binder不是linux系统内核的一部分,
    >
    > 2.linux的 动态内核可加载模块 的机制。模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核做为内核的一部分运行。android系统通过动态添加一个内核模块运行在内核空间。负责各个用户进程通过binder实现通信的内核就叫 Binder 驱动（binder dirver）。

  * 内存映射

    > 1.binder ipc 内存映射通过 mmap()来实现，mmap()是操作系统中一种内存映射的方法。
    >
    > 2.将用户空间的一块内存区域映射到内核空间，
    >
    > 3.映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。
    >
    > 4.内存映射减少数据拷贝次数。

* 3.2 Binder IPC 实现原理

  * mmap()  内存映射

    > 1.mmap()通常是用在有物理介质的文件系统上。
    >
    > 2.一般读取磁盘上的数据 需要 两次拷贝(磁盘->内核空间->用户空间)；mmap 通过物理介质和用户空间之间建立映射，减少拷贝次数。
    >
    > 3.binder 不存在物理介质，binder使用mmap(),用来在内核空间创建数据接受的缓存空间。

  * 完整的BInder IPC 通信过程通常是这样:

    > 1.首先binder驱动 在内核空间创建了一个**数据接受缓存区**；
    >
    > 2.接着在内核空间开辟一块**内核缓存区**，建立**内核缓存区**和内核中**数据接受缓存区**之间的映射关系，以及内核中数据接受缓存区和**接受进程用户空间地址**的映射关系。
    >
    > 3.发送方进程通过系统调用copy_from_user()将数据copy到**内核缓存区**，由于内核缓存区和接受进程的用户空间存在内存映射，因此也就相当于把数据发送到了接受进程的用户空间，这样便完成了一次进程进程间的通信。

## 四、Binder 通信模型

* 4.1client/server/serviceManger/驱动
  * client、server、serviceManger运行在用户空间，binder驱动在内核空间。serviceManger和binder 由系统提供，client和server由应用程序实现
  * client、server和ServiceManager均是通过系统调用open、mmap和ioctl来访问设备文件/dev/binder，从而实现binder 驱动的交互来间接的实现跨进程通信。
* 4.2 binder 通信过程
  * 1、首先一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过binder驱动将自己注册成为 ServiceManger；
  * 2、server 通过驱动向serverManger 中注册Binder (Server中的bidner 实体)，表明可以对外提供服务。驱动为这个binder创建位于内核中的实体节点以及ServiceManger对实体的引用，将名字以及新建的引用打包传给ServiceManger，ServiceManger将其填入查找表。
  * 3、client通过名字，在binder驱动的帮助下从ServiceMager中获取到对Binder实体的引用，通过这个引用就能实现和Server进程的通信。
* 4.3 Binder 通信中的代理模式
  * A进程获取b进程时的objet 时，驱动会返回一个跟object一样的代理对象，具有跟object一样的方法。 
  * 当binder 驱动接受到A 进程的消息后，发现这是个代理对象(objectProxy)就去查询自己维护的表单，一查发现这个是B进程object的代理对象。于是就会去通知B进程调用object的方法，并要求B进程把返回的结果发给自己。当驱动拿到B进程的返回结果后 就转发给A进程，这样一次通信就完成了。
* 4.4 Binder 的完整定义
  * 从进程间通信的角度看，Binder是一种进程间通信机制；
  * 从server 进程的角度看Binder 指的是Server 中的BInder 实体对象。
  * 从client 进程的角度看，Binder指的是对Binder代理对象，是Binder实体对象的一个远程代理
  * 从传输过程的角度看，Binder 是一个可跨进程传输的对象；Binder驱动会对这个跨越进程边界的对象一点点特殊处理，自动完成代理对象和本地对象之间的转换。
* 线程池
  * 客户端与binder建立链接 是有线程池做管理，当一个进程与binder的连接数大于16时，会被阻塞。



## 五、Binder四个重要对象

* IBinder

  > 只要实现了这个接口 就具备了跨进程的能力

* IInterface

  > server端具备什么样的能力，具备什么样的功能。

* Binder

  > binder 的本地类，代理类

* Stub

  > binder 的本地对象，server端给client的代理类
  
* 一次binder android 的调用。

























