# 一、JVM

* java 虚拟机的回收算法

  > 先回收之前 我们需要做对象存活判断，一个是引用计数，一个是可达性分析。
  >
  > 然后就是 收集的算法有4中，
  >
  > * 标记-清除 算法，首先 标记出所有需要回收的对象，完成后统一回收。有两缺点，效率不高，清除会内存碎片产生。
  > * 复制算法  将内存分为两块，当一块用完了，将还活着的对象复制到另一块，然后将用完了的这块内存清理掉。优点是云行高效，缺点是只有一半的内存，复制长生存期对象也会导致效率降低
  > * 标记-整理算法  与标记-清除一样，不同的是 不直接清除内存，而是让存活对象向一端移动，然后清理端边界以外的内存。、
  > * 分代收集算法 把java 堆分为 新生代 和老年代 ，新生代 就是每次收集时会有大批对象死去，就用复制算法。老年代相反，每次收集时 对象存活率高，就使用 标记-清理 或者 标记-整理。



****

# 二、集合

* ArrayList 跟linkList的区别

  * 1、底层数据结构不同，ArrayList 数据结构是数组，通过索引可以查询到对应的数据。LinkedList 数据结构是双向链表结构，每个元素都有上一个和下一个元素的引用。
  * 2、 相对于ArrayList ,LinkedList 的插入、添加、删除速度更快，因为元素添加到集合种任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。但是，查询速度更慢，数组通过索引就可以查到数据，链表只能挨个查询。
  * 3、LinkedList比ArrayList 更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向上一个元素，一个指向下一个元素。
* ArrayList的数组大小是如何保证可以添加大量数据的
  * arraylist 有一个自动扩容的机制，如果arraylist的大小已经不满足需求时，那么将数组变原长度的1.5倍，之后操作就是把老的数组拷贝到新的数组里面。
* hashMap的实现原理

  * HashMap 结构
* 数据+链表。每个entry元素就是一个数组的元素，它将key-value 的数值以键值队的形式进行存储，并且entry 是一个链表结构，next 指向另外一个entry 元素
  * HashMap 工作原理
    * HashMap 基于 hashing 原理，我们通过 put() 和 get() 方法储存和获取对象。当我们将键值对传递给 put() 方法时，它调用键对象的 hashCode() 方法来计算 hashcode，让后找到 bucket 位置来储存 Entry 对象。当两个对象的 hashcode 相同时，它们的 bucket 位置相同，‘碰撞’会发生。因为 HashMap 使用链表存储对象，这个 Entry 会存储在链表中，当获取对象时，通过键对象的 equals() 方法找到正确的键值对，然后返回值对象。
* set 与list 的区别

## 三、java 多线程

* 对java多线程编程的理解

  * 线程与进程

    * 线程是程序中单独的控制流，依靠程序进行运行，只能使用分配给程序的资源和环境
    * 进程是执行中的程序，一个进程可以包含一个或者多个线程，进程至少要包含一个线程。
    * 程序中只存在一个线程，实际上主方法就是一个 主线程
    * 多线是在一个程序中运行多个任务，目的是更好的使用cpu资源
    * 一个线程执行到底，相当于单线程，叫串行；多个线程交替执行，抢占cpu时间片，速度很快，称为 线程并发；多个线程在不同的cpu中同时执行 称为线程并行。

  * 线程的现实

    * 线程有两种实现方式：1、继承Thread 类，在Run 方法里面实现功能，创建该类的实例对象，调用start()方法。2、实现Runnable 接口，创建该类实例对象，new 出Thread 对象 并将该类对象传递给Thread 构造方法， 然后执行Thread 实例对象的start() 。

      

  * 线程的状态

    * 创建状态：准备好了一个多线程的对象。
    * 就绪状态：调用了start()方法，等待cpu进行调度
    * 运行状态：执行run()方法。
    * 阻塞状态：暂停执行执行，可能将资源交给其他线程使用(wait() sleep() )
    * 终止状态(死亡状态):线程销毁了 ；当线程程序执行完，或线程调用stop的时候  initerrupt() 中断线程。

  * 线程常用的方法

    * getName ：获取线程名。
    * currentThread();获取当前线程对象。
    * isAlive() 判断线程是否启动
    * join() 线程的强行执行，当调用这个方法的时候，就会优先执行线程，然后继续执行当前程序。
    * sleep() 当前线程进行休眠。
    * yield() 礼让，优先让其他线程执行

  * 线程的优先级

    * shePriority() 设置线程的优先级，有一定的影响。不是绝对。

  * 线程同步 

    * 多个线程方问 成员变量的时候，由于内存共享的愿意会导致变量的属性值 出问题，所有需要同步代码块，同时只能有一个线程访问该段代码。

  * 线程生命周期

    * new Thread() 新建线程 
    * start（） 运行 
    * yield() 其他线程优先执行，然后再执行
    * sleep() wait() 睡眠状态
    * notify()  notifyAll()    恢复运行
    * stop()   销毁

  * 锁的类型

    * 悲观锁：使用数据时，一定会有其他线程来修改数据，因此再获取数据的时候会先加锁，确保数据不会被别的线程修改。
    * 乐观锁：使用数据时，不会有其他线程修改数据，所以不添加锁，只是再更新数据的时候去判断之前有没有别的线程更新了这个数据。如果没更新，成功写入。如果更新了，根据不同的实现方式执行不同的操作。
    * 自旋锁:锁住同步资源失败，不阻塞线程。
    * 死锁：当前线程拥有其他线程需要的资源，当前线程等待其他线程已拥有的资源，都不放弃自己拥有的资源.

  * 

## 四、字符串

* stringbuffer与StringBuild的区别





